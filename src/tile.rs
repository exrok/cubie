use crate::cube::center::CenterMap;
use crate::cube::corner::Corner;
use crate::cube::edge::Edge;
use crate::{ CornerMap, MapError };
use crate::Cube;
use crate::EdgeMap;
use crate::Face;
use crate::FixedCentersCube;

#[derive(Clone, PartialEq, Eq, Debug)]
pub enum TileMapConversionError {
    InvalidPiece,
    MissingTile,
    Corner(MapError),
    Center(MapError),
    Edge(MapError),
}

use TileMapConversionError as TMErr;

#[derive(Default, Clone, PartialEq, Eq, Debug)]
pub struct TileMap {
    pub map: [[Option<Face>; 9]; 6],
}

impl From<Cube> for TileMap {
    fn from(cube: Cube) -> TileMap {
        let mut tilemap: TileMap = Default::default();
        tilemap.store_centers(cube.centers());
        tilemap.store_edges(cube.edges());
        tilemap.store_corners(cube.corners());
        tilemap
    }
}
impl From<FixedCentersCube> for TileMap {
    fn from(cube: FixedCentersCube) -> TileMap {
        let mut tilemap: TileMap = Default::default();
        tilemap.store_identity_centers();
        tilemap.store_edges(cube.edges);
        tilemap.store_corners(cube.corners);
        tilemap
    }
}

impl From<CenterMap> for TileMap {
    fn from(centers: CenterMap) -> TileMap {
        let mut tilemap: TileMap = Default::default();
        tilemap.store_centers(centers);
        tilemap
    }
}
impl From<CornerMap> for TileMap {
    fn from(corners: CornerMap) -> TileMap {
        let mut tilemap: TileMap = Default::default();
        tilemap.store_identity_centers();
        tilemap.store_corners(corners);
        tilemap
    }
}

impl From<EdgeMap> for TileMap {
    fn from(edges: EdgeMap) -> TileMap {
        let mut tilemap: TileMap = Default::default();
        tilemap.store_identity_centers();
        tilemap.store_edges(edges);
        tilemap
    }
}

use crate::cube::edge::Flip;
fn edge_from_faces(a :Face, b:Face ) -> Option<(Edge, Flip)>{
    use Edge::*;
    use Flip::*;

    // for edge in Edge::edges() {
    //     let (a,b) = edge.faces();
    //     let ai = a as usize;
    //     let bi = b as usize;
    //     bff[ai*6+bi] = Some((edge, Flip::Identity));
    //     bff[bi*6+ai] = Some((edge, Flip::Flipped));
    //     // eprintln!("{:?} edge", edge.faces())
    // }
    let map = [None, None, Some((FU, Flipped)), Some((BU, Flipped)), Some((RU, Flipped)),
     Some((LU, Flipped)), None, None, Some((FD, Flipped)), Some((BD, Flipped)),
     Some((RD, Flipped)), Some((LD, Flipped)), Some((FU, Identity)), Some((FD, Identity)),
     None, None, Some((FR, Identity)), Some((FL, Identity)), Some((BU, Identity)),
     Some((BD, Identity)), None, None, Some((BR, Identity)), Some((BL, Identity)),
     Some((RU, Identity)), Some((RD, Identity)), Some((FR, Flipped)), Some((BR, Flipped)),
     None, None, Some((LU, Identity)), Some((LD, Identity)), Some((FL, Flipped)),
     Some((BL, Flipped)), None, None];
    map[a as usize *6 + b as usize]
}
pub fn tiles_from_edge(edge :Edge) -> (usize,usize) {
    match edge {
        Edge::LU => (46, 3),
        Edge::LD => (52, 12),
        Edge::RU => (37, 5),
        Edge::RD => (43, 14),
        Edge::BL => (32, 48),
        Edge::FL => (21, 50),
        Edge::FR => (23, 39),
        Edge::BR => (30, 41),
        Edge::BU => (28, 1),
        Edge::FD => (25, 10),
        Edge::FU => (19, 7),
        Edge::BD => (34, 16),
    }
}
pub fn tiles_from_corner(corner: Corner) -> [usize;3] {
    match corner {
        Corner::ULF => [47, 6, 18],
        Corner::DLF => [53, 9, 24],
        Corner::ULB => [45, 0, 29],
        Corner::URF => [36, 8, 20],
        Corner::URB => [38, 2, 27],
        Corner::DLB => [51, 15, 35],
        Corner::DRF => [42, 11, 26],
        Corner::DRB => [44, 17, 33],
    }
}

    use crate::cube::corner::Twist;
impl TileMap {
    pub fn as_array(&self) -> &[Option<Face>; 54] {
        unsafe { std::mem::transmute(&self.map) }
    }
    pub fn as_array_mut(&mut self) -> &mut [Option<Face>; 54] {
        unsafe { std::mem::transmute(&mut self.map) }
    }
    pub fn cube(&self) -> Result<Cube,TMErr> {
        Ok(Cube::new(self.centers()?, self.corners()?, self.edges()?))
    }
    pub fn fc_cube(&self) -> Result<FixedCentersCube,TMErr> {
        Ok(self.cube()?.into())
    }
    pub fn autofill(&mut self) {
        let tiles = self.as_array_mut();

        let mut corner_acc = 0;
        let mut twist_acc = Twist::Identity;
        let mut unset_acc = None;
        let mut set_cnt =0; 
        for pos in Corner::corners() {
            let map = tiles_from_corner(pos);
            let mut unset = 0;
            let mut cnt = 0;
            let mut f = [0,0,0];
            for i in 0..3 {
                if let Some(face) = tiles[map[i]] {
                    f[i] = face as u64;
                    cnt+=1;
                } else {
                    unset = i;
                }
            }
            if cnt == 2 {
                f[unset] = (f[0]^f[1]^f[2]^0b110)&0b110;
                if f[unset]&0b110 == 0b110 {//two same faces
                    continue;
                }
                let corner = ((f[ 0 ]&1) << (f[ 0 ] >> 1)) | ((f[ 1 ]&1) << (f[ 1 ] >> 1)) | ((f[ 2 ]&1) << (f[ 2 ] >> 1));
                let y_axis = if (f[ 0 ] & 0b110) == 0 {
                    f[2]
                } else if (f[ 1 ] & 0b110) == 0 {
                    f[0]
                } else  {
                    f[1]
                };

                if (((0b01101001_00) >> ((pos as u64) ^ (corner as u64))) ^ y_axis)&0b100 != 0 {
                    f[unset] ^= 1;
                }
                tiles[map[unset]] = Some(unsafe{std::mem::transmute(f[unset] as u8)});
            }
            if cnt < 2 {
                unset_acc = Some(pos); 
                continue;
            }
            let [f1,f2,f3] = f;

            if (f1 ^ f2 ^ f3) & 0b110 != 0b110 {
                continue;
            }
            // corner may still be wrong if 2-cycle in above faces thus test y_axis consistancty
            let corner = ((f1&1) << (f1 >> 1)) | ((f2&1) << (f2 >> 1)) | ((f3&1) << (f3 >> 1));
            let (mut twist, y_axis) = if (f1 & 0b110) == 0 {
                (Twist::Ccw,f3)
            } else if (f2 & 0b110) == 0 {
                (Twist::Identity,f1)
            } else if (f3 & 0b110) == 0 {
                (Twist::Cw,f2)
            } else {
                continue;
            };

            if (((0b01101001_00) >> ((pos as u64) ^ (corner as u64))) ^ y_axis)&0b100 != 0 {
                continue;
            }

            let a =  pos as u64;
            if (a ^ (a >> 1) ^ (a >> 2)) & 0b1 == 1 {
                twist = twist.inverse();
            }

            corner_acc ^= corner as u64;
            twist_acc = twist_acc*twist;
            set_cnt+=1;
        }
        if set_cnt == 7 {
            if let Some(unset_acc) = unset_acc {
                let c:Corner = unsafe{std::mem::transmute(corner_acc as u8)};
                let map = tiles_from_corner(unset_acc);
                let a = (unset_acc as u32);
                if (a ^ (a >> 1) ^ (a >> 2)) & 0b1 == 1 {
                    eprintln!("inversed");
                    twist_acc = twist_acc.inverse();
                }
                eprintln!("AUTOFILE: {:?}",twist_acc);
                let new = match twist_acc.inverse() {
                    Twist::Identity => [c.x(),c.y(),c.z()],
                    Twist::Cw => [c.z(),c.x(),c.y()],
                    Twist::Ccw => [c.y(),c.z(),c.x()],
                }; 
                if map.iter().map(|m|tiles[*m]).zip(new.iter()).all(|(o,n)| {
                    o.map_or(true, |a| a == *n)
                }) {
                    for i in 0..3 {
                        tiles[map[i]] = Some(new[i]);
                    }
                }

            }
        }
        let mut edge_masks = [
            0b111111 ^ (1<<Face::Up as u8) ^(1<<Face::Down as u8),
            0b111111 ^ (1<<Face::Up as u8) ^(1<<Face::Down as u8),
            0b111111 ^ (1<<Face::Front as u8) ^(1<<Face::Back as u8),
            0b111111 ^ (1<<Face::Front as u8) ^(1<<Face::Back as u8),
            0b111111 ^ (1<<Face::Right as u8) ^(1<<Face::Left as u8),
            0b111111 ^ (1<<Face::Right as u8) ^(1<<Face::Left as u8),
        ];
        let mut face_cnts = [0,0,0,0,0,0];

        for pos in Edge::edges() {
            let (t1, t2) = tiles_from_edge(pos);
            let (f1, f2) = (tiles[t1], tiles[t2]);
            if let Some(face) = f1 {
                face_cnts[face as usize] += 1;
                if let Some(other_face) = f2 {
                    edge_masks[face as usize] &= !(1<<(other_face as u8));
                }
            }
            if let Some(face) = f2 {
                face_cnts[face as usize] += 1;
                if let Some(other_face) = f1 {
                    edge_masks[face as usize] &= !(1<<(other_face as u8));
                }
            }
        }
        let mut t_mask = 0;
        for (face,&cnt) in face_cnts.iter().enumerate() {
            if cnt < 4 {
                t_mask |= 1 << face;
            }
        }
        for _ in 0..3 {
            for pos in Edge::edges() {
                let (t1, t2) = tiles_from_edge(pos);
                match ((tiles[t1],t1), (tiles[t2],t2)) {
                    ((Some(face),_),(None,tile))| ((None,tile),(Some(face),_)) => {
                        let opt = (t_mask & edge_masks[face as usize]) as u8;
                        if opt.count_ones() != 1 {
                            continue;
                        }
                        let fc: Face = unsafe {std::mem::transmute(opt.trailing_zeros() as u8) };
                        tiles[tile] = Some(fc);
                        face_cnts[fc as usize] += 1;
                        edge_masks[fc as usize] &= !(1 << (face as u8));
                        edge_masks[face as usize] &= !(1 << (fc as u8));
                        if face_cnts[fc as usize] >= 4 {
                            t_mask &= !(1 << (fc as u8)) 
                        }
                    }
                    _ => {
                    }
                }
            }
        }

    }
    pub fn edges(&self) -> Result<EdgeMap, TMErr> {
        let tiles = self.as_array();
        let mut raw = 0;
        for pos in Edge::edges() {
            let (t1, t2) = tiles_from_edge(pos);
            let (edge, flip) = edge_from_faces(tiles[t1].ok_or(TMErr::MissingTile)?,
                                               tiles[t2].ok_or(TMErr::MissingTile)?)
                .ok_or(TMErr::InvalidPiece)?;
            let parity = flip as u64 ^ (((edge as u64 ^ pos as u64) >> 2) & 1);
            let offset = edge as u32;
            raw |= parity << (4+offset*5);
            raw |= (pos as u64) << (offset*5);
        }
        EdgeMap::from_raw(raw).map_err(|err| TMErr::Edge(err))
    }

    pub fn centers(&self) -> Result<CenterMap, TMErr> {
        let y1 = self.map[Face::Up as usize][4].ok_or(TMErr::MissingTile)? as u64;
        let y2 = self.map[Face::Down as usize][4].ok_or(TMErr::MissingTile)?as u64;
        if (y1 ^y2) != 1 {
            return Err(TMErr::Center(MapError::Orientation));
        }
        let x1 = self.map[Face::Front as usize][4].ok_or(TMErr::MissingTile)?as u64;
        let x2 = self.map[Face::Back as usize][4].ok_or(TMErr::MissingTile)?as u64;
        if (x1 ^x2) != 1 {
            return Err(TMErr::Center(MapError::Orientation));
        }
        let z1 = self.map[Face::Right as usize][4].ok_or(TMErr::MissingTile)?as u64;
        let z2 = self.map[Face::Left as usize][4].ok_or(TMErr::MissingTile)?as u64;
        if (z1 ^z2) != 1 {
            return Err(TMErr::Center(MapError::Orientation));
        }
        CenterMap::from_raw((y1 << 5) | (x1 << (8+5)) | (z1 << (16+5)))
            .map(|centers| centers.inverse())
            .map_err(|err| TMErr::Center(err))
    }
    pub fn corners(&self) -> Result<CornerMap, TMErr> {
        let tiles = self.as_array();
        let mut raw = 0;
        for pos in Corner::corners() {
            let [t1, t2, t3] = tiles_from_corner(pos);
            let (f1, f2, f3) = (tiles[t1].ok_or(TMErr::MissingTile)? as u64,
                                tiles[t2].ok_or(TMErr::MissingTile)? as u64,
                                tiles[t3].ok_or(TMErr::MissingTile)? as u64);
            if (f1 ^ f2 ^ f3) & 0b110 != 0b110 {
                return Err(TMErr::InvalidPiece); // sanity
            }
            // corner may still be wrong if 2-cycle in above faces thus test y_axis consistancty
            let corner = ((f1&1) << (f1 >> 1)) | ((f2&1) << (f2 >> 1)) | ((f3&1) << (f3 >> 1));
            let (mut twist, y_axis) = if (f1 & 0b110) == 0 {
                (Twist::Ccw,f3)
            } else if (f2 & 0b110) == 0 {
                (Twist::Identity,f1)
            } else if (f3 & 0b110) == 0 {
                (Twist::Cw,f2)
            } else {
                return Err(TMErr::InvalidPiece); // sanity
            };

            if (((0b01101001_00) >> ((pos as u64) ^ (corner as u64))) ^ y_axis)&0b100 != 0 {
                return Err(TMErr::InvalidPiece); // sanity
            }

            let a =  pos as u64;
            if (a ^ (a >> 1) ^ (a >> 2)) & 0b1 == 1 {
                twist = twist.inverse();
            }
            raw |= (twist as u64) << (corner as u32*8 + 3);
            raw |= (pos as u64) << (corner as u32*8);
        }
        CornerMap::from_raw(raw).map_err(|err| TMErr::Corner(err))
    }
    /// Render a 3d picture of the cube using VT escape codes on a compatible 256-color terminal.
    ///
    /// By default, `Front` is <span style="border-bottom:2px solid  #ff0000;">red</span> ,
    /// `Back` is <span style="border-bottom:2px solid  #ffaf00;">orange</span>,
    /// `Up` is <span style="border-bottom:2px solid  #ffff00;">yellow</span>,
    /// `Down` is <span style="border-bottom:2px solid  #e4e4e4;">white</span>,
    /// `Right` is <span style="border-bottom:2px solid  #5fd700;">green</span> and
    /// `Left` is <span style="border-bottom:2px solid  #0087ff;">blue</span>.
    ///
    /// # Example
    ///
    /// ```
    /// use speedcube::{Move, TileMap};
    /// let cube = Move::Rcw.cube();
    /// let cornermap = Move::Ucw.corners();
    /// println!("{}", TileMap::from(cube).terminal_display());
    /// println!("{}", TileMap::from(cornermap).terminal_display());
    /// ```
    ///
    /// Will output:    
    /// <div>
    /// <img  style="width:100%; max-width:207px;image-rendering: pixelated;
    ///    image-rendering: -moz-crisp-edges;image-rendering: crisp-edges;"
    ///   src="data:image/png;base64,
    /// iVBORw0KGgoAAAANSUhEUgAAAEUAAABrBAMAAADTBVJcAAAAG1BMVEVBAAAICAgAh////wD/rwD/
    /// AABf1wDk5OR2dnabo1jqAAAAAXRSTlMAQObYZgAAAtVJREFUeAHN1bGR2zAQhWG6AzyalJGeWrgW
    /// 0MAFaIEtKL4MZXv/WQyFwRHCWJE3gGzpGzw+XrALw/wKi4+az2YgazX6rD9u+kHuGMgnCJPUEwyE
    /// kRtQQ9wQBAFhNrW3uAFU5ibpScx8hBrECRImqRLMxxrOIM6sTZjfOoO03htgJGclYYj1IEgTlJkt
    /// CfMZFg9a73sbBNKWNp1GxO25DTJ2mElyQxAm5ybICCYlYQgizszeBN2Oo/Yyo9oLk59BZrbaKzx7
    /// YfIZhLnohfnjQZjrXpgHQZhRL8zDg8a9MB501St4r2rEVaHrZdZ7YQjCLG0vI0vtJTO1l32p0/C/
    /// 5ezlQXbyrdwQhOl7YQxhCGL6XhiGXgQxXa/TAOq/ul6NOQWo77VcTNdruZy21zUBYcZBFVUzJiAM
    /// t7xGBE1Gtzl56DGNYjS5BfIKASqbBPk5CeJMmgQZSUmToMSEl/ck0CCsCYJcTRs0LD8J8pkE+UyC
    /// KpoSEGQ2kHfmH/by3u/lVT9I7vfyeldPMBBGbkBPEqtRAdnpJqohBQMphjjlpuhJzHwFIwwnSBgQ
    /// ZMd8xeA3nGcUhnY8LjzWJ2lPYXjwPZv5hjDtGYsw94CJ32sstx/3xLLpNFrvZo7ueZKZpGq+7BNz
    /// tL2UEiYJY40w32Zicw8/Y6LMKJKpFVPO5+HnTZiisNCPdSlMgYAKJglT3HxYXBTG20WMNgs6jYiL
    /// fHi7hCGO7zC8QOKwmMMDiPNPDC+QuFJ2YTaM+NnvMyO/ImCyqtFBhjDJ97LFmcVkYRIdyfB+bows
    /// uzBRZnTDsCCF6fdyLNpUMHUvY7q97E3avYxp9nIUJmKavZzavUxQNSqjvexBfo72sr9Gv220lzFZ
    /// /gKHe7m+RgzkGmFuGMgIVQMZI8x0L+f/ai8XkJ2vSDHEqTFhOIfIbzjP4YIrzTlq1J7hjXsmzzPp
    /// NX0/8/f8/t8LNCWgt/byX1Vp2biqclFaAAAAAElFTkSuQmCC">
    /// </div>
    pub fn terminal_display(&self) -> impl fmt::Display + '_ {
        return TileMap3dFmt { fm: &self };
    }
    pub fn store_identity_centers(&mut self) {
        for face in Face::faces() {
            self.map[face as usize][4] = Some(face);
        }
    }
    pub fn store_centers(&mut self, centers: CenterMap) {
        for face in Face::faces() {
            self.map[centers.get(face) as usize][4] = Some(face);
        }
    }
    pub fn store_edges(&mut self, edges: EdgeMap) {
        let fm: &mut [Option<Face>; 54] = unsafe { std::mem::transmute(&mut self.map) };
        for (edge, (pos, flipped)) in edges.iter() {
            let (mut a, mut b) = edge.faces();
            let position_parity = ((edge as u8 ^ pos as u8) >> 2) & 1;
            if position_parity != (flipped as u8) {
                std::mem::swap(&mut a, &mut b);
            }
            let (a_index, b_index) = tiles_from_edge(pos);
            fm[a_index as usize] = Some(a);
            fm[b_index as usize] = Some(b);
        }
    }

    pub fn store_corners(&mut self, cm: CornerMap) {
        let mut xm = 0x5050505_04040404;
        let mut zm = 0x3030202_03030202;
        let ym = 0x01000100_01000100;
        let pm = 0x08000008_00080800;
        const MASK: u64 = 0x08080808_08080808;

        let pfilter = |x| (MASK - x) | x;

        let parity = (!((cm.raw << 3) ^ (cm.raw << 2) ^ (cm.raw << 1))) & MASK;

        let b_flip = (!pfilter((parity ^ pm) >> 3)) & (xm ^ zm); // adjust side facelet
        xm ^= b_flip;
        zm ^= b_flip;

        let mnx = (cm.raw | (cm.raw >> 1)) & parity;
        let cm = cm.raw ^ mnx ^ (mnx << 1);

        let cw = pfilter((cm & MASK) >> 3);
        let ccw = pfilter(((cm >> 1) & MASK) >> 3);
        let nil = !(cw | ccw);

        let xmj = nil & xm | ccw & zm | cw & ym; // apply orientation
        let ymj = nil & ym | ccw & xm | cw & zm;
        let zmj = nil & zm | ccw & ym | cw & xm;
        let fm: &mut [Option<Face>; 54] = unsafe { std::mem::transmute(&mut self.map) };

        for _i in 0..8 {
            let i = _i * 8;
            use Corner::*;
            let (xp, yp, zp) = match Corner::from((cm >> i) as u8) {
                ULF => (47, 6, 18),
                DLF => (53, 9, 24),
                ULB => (45, 0, 29),
                URF => (36, 8, 20),
                URB => (38, 2, 27),
                DLB => (51, 15, 35),
                DRF => (42, 11, 26),
                DRB => (44, 17, 33),
            };
            fm[xp] = Some(unsafe { std::mem::transmute((xmj >> i) as u8) });
            fm[yp] = Some(unsafe { std::mem::transmute((ymj >> i) as u8) });
            fm[zp] = Some(unsafe { std::mem::transmute((zmj >> i) as u8) });
        }
    }
}

struct TileMap3dFmt<'a> {
    fm: &'a TileMap,
}
use std::fmt;
impl fmt::Display for TileMap3dFmt<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let fm: &[Option<Face>; 54] = unsafe { std::mem::transmute(&self.fm.map) };

        let color_code = |a: &Option<Face>| match a {
            Some(Face::Up) => 226,    // yellow
            Some(Face::Down) => 254,  // white
            Some(Face::Front) => 196, // red
            Some(Face::Back) => 214,  // orange
            Some(Face::Right) => 76,  // greeen
            Some(Face::Left) => 33,   // blue
            None => 243,              // dark grey
        };
        let mut prev_style = 0;
        for line in CLI_CUBE_IMAGE {
            f.write_str("\x1b[38;5;232m")?;
            for block in line.iter() {
                let chr = [" ", "▄", "▀", "█"][(block & 0b11) as usize];
                let face_index = (block >> 2) as usize;
                let style = fm.get(face_index).map(color_code).unwrap_or(0);
                if prev_style != style {
                    if style == 0 {
                        f.write_str("\x1b[49m")?;
                    } else {
                        write!(f, "\x1b[48;5;{}m", style)?;
                    }
                }
                prev_style = style;
                f.write_str(chr)?;
            }
            f.write_str("\x1b[0m\n")?;
        }
        Ok(())
    }
}


#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn center_extraction() {
        for rotation_cube in crate::moves::ROTATION_TABLE {
            let tm:TileMap = rotation_cube.centers().into();
            assert_eq!(tm.centers(), Ok(rotation_cube.centers()));
        }
    }
    #[test]
    fn corner_extraction() {
        use crate::Move;
        let tilemap:TileMap =( CornerMap::default()*Move::F2 ).into();
        assert_eq!(tilemap.corners(), Ok( CornerMap::default() * Move::F2) );

        let tilemap:TileMap =( CornerMap::default()*Move::Fcw ).into();
        assert_eq!(tilemap.corners(), Ok( CornerMap::default() * Move::Fcw) );

        let cube = Move::Fcw.corners()*Move::Lcw*Move::Bcw*Move::U2*Move::Dccw;
        let tilemap:TileMap =( cube ).into();
        assert_eq!(tilemap.corners(), Ok( cube) );
    }
    #[test]
    fn edge_extraction() {
        use crate::Move;
        let tilemap:TileMap =( EdgeMap::default() * Move::Rcw * Move::Lcw).into();
        assert_eq!(tilemap.edges(), Ok( EdgeMap::default()* Move::Rcw * Move::Lcw) )
    }
    #[test]
    fn tile_rotations_conversions() {
        let mut map_table: [TileMap; 24] = Default::default();
        fn assert_equal_filled_tiles(a: &TileMap, b: &TileMap, skip_centers: bool) {
            for (face_a, face_b) in a.map.iter().zip(b.map.iter()) {
                for (index, x) in face_a.iter().zip(face_b.iter()).enumerate() {
                    if index == 4 && skip_centers {
                        continue;
                    } // skip centers
                    if let (Some(face_a), Some(face_b)) = x {
                        assert_eq!(face_a, face_b);
                    }
                }
            }
        }
        for (rotation_cube, entry) in crate::moves::ROTATION_TABLE
            .iter()
            .zip(map_table.iter_mut())
        {
            *entry = TileMap::from(*rotation_cube);
            assert_equal_filled_tiles(entry, &rotation_cube.corners().into(), true);
            assert_equal_filled_tiles(entry, &rotation_cube.centers().into(), false);
            assert_equal_filled_tiles(entry, &rotation_cube.edges().into(), true);

            //rotations cubes should be all solved and specify every piece
            for face in entry.map.iter() {
                let center_tile = face[0].unwrap();
                for tile in face.iter() {
                    assert_eq!(tile.unwrap(), center_tile);
                }
            }
        }
        //All rotations cubes are distinct, the tile maps should be as well
        for x in 0..24usize {
            for y in (x + 1)..24 {
                assert_ne!(&map_table[x], &map_table[y]);
            }
        }
    }
}

pub const CLI_CUBE_IMAGE: &[[u8; 69]] = &[
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDD, 0xDD, 0xB6, 0xDF, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDD, 0xDD, 0x02, 0x02, 0xDD, 0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDF, 0x76, 0xDD, 0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0xB6, 0xB6,
        0xB4, 0xB4, 0xB4, 0xDF, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD,
        0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0xDD, 0xDD, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDF, 0x74, 0x74, 0x74, 0x76, 0x76, 0xDD, 0xDD, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0xBA, 0xBA, 0xB8, 0xDF, 0xB4, 0xB4,
        0xB4, 0xB4, 0xB4, 0xDF, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0x0E, 0x0E, 0x0C, 0x0C,
        0x0E, 0x0E, 0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x06, 0x06, 0x04, 0x04, 0x06, 0x06, 0xDD,
        0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDF, 0x74, 0x74, 0x74, 0x74, 0x74, 0xDF, 0x70, 0x72, 0x72,
        0xDD, 0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0xBE, 0xDF, 0xB8, 0xB8, 0xB8, 0xB8, 0xB8, 0xDF, 0xB4, 0xB4,
        0xB5, 0xB5, 0xC2, 0xDF, 0xDC, 0xDD, 0xDD, 0x1A, 0x1A, 0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C,
        0x0C, 0x0C, 0x0D, 0x0D, 0x12, 0x12, 0x05, 0x05, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05,
        0x05, 0x0A, 0x0A, 0xDD, 0xDD, 0xDF, 0x82, 0x75, 0x75, 0x74, 0x74, 0xDF, 0x70, 0x70, 0x70,
        0x70, 0x70, 0xDF, 0x6E, 0xDD, 0xDD, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDD, 0xBE, 0xBE, 0xBC, 0xBC, 0xBC, 0xDF, 0xB8, 0xB8, 0xB8, 0xB8, 0xB9, 0xDF, 0xC2, 0xC2,
        0xC0, 0xC1, 0xC1, 0x1A, 0x1A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1A, 0x1A, 0x0D, 0x0D,
        0x12, 0x12, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x12, 0x12, 0x05, 0x05, 0x0A, 0x0A, 0x08,
        0x08, 0x08, 0x08, 0x08, 0x08, 0x0A, 0x0A, 0x81, 0x80, 0x82, 0x82, 0xDF, 0x71, 0x70, 0x70,
        0x70, 0x70, 0xDF, 0x6C, 0x6C, 0x6C, 0x6E, 0x6E, 0xDD,
    ],
    [
        0xDF, 0xBC, 0xBC, 0xBC, 0xBC, 0xBC, 0xDF, 0xB9, 0xB9, 0xC6, 0xC6, 0xC4, 0xDF, 0xC0, 0xC0,
        0xC0, 0xDF, 0x48, 0x4A, 0x4A, 0x19, 0x19, 0x18, 0x18, 0x19, 0x19, 0x1E, 0x1E, 0x1C, 0x1C,
        0x1E, 0x1E, 0x11, 0x11, 0x10, 0x10, 0x11, 0x11, 0x16, 0x16, 0x14, 0x14, 0x16, 0x16, 0x09,
        0x09, 0x08, 0x08, 0x09, 0x09, 0x9A, 0x9A, 0xDF, 0x80, 0x80, 0x80, 0xDF, 0x7C, 0x7E, 0x7E,
        0x71, 0x71, 0xDF, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0xDF,
    ],
    [
        0xDF, 0xBC, 0xBC, 0xBD, 0xBD, 0xCA, 0xDF, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xDF, 0xC0, 0xC0,
        0xC1, 0xDF, 0x48, 0x48, 0x48, 0x48, 0x48, 0xDF, 0x4E, 0x1D, 0x1D, 0x1C, 0x1C, 0x1C, 0x1C,
        0x1C, 0x1C, 0x1D, 0x1D, 0x22, 0x22, 0x15, 0x15, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x15,
        0x15, 0xDF, 0x9A, 0x98, 0x98, 0x98, 0x98, 0xDF, 0x81, 0x80, 0x80, 0xDF, 0x7C, 0x7C, 0x7C,
        0x7C, 0x7C, 0xDF, 0x7A, 0x6D, 0x6D, 0x6C, 0x6C, 0xDF,
    ],
    [
        0xDF, 0xCA, 0xCA, 0xC8, 0xC8, 0xC8, 0xDF, 0xC4, 0xC4, 0xC4, 0xC4, 0xC5, 0xDF, 0xCE, 0xCE,
        0xCC, 0xDF, 0x49, 0x48, 0x48, 0x48, 0x48, 0xDF, 0x4C, 0x4C, 0x4C, 0x4E, 0x4E, 0x1D, 0x1D,
        0x22, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x22, 0x15, 0x15, 0x96, 0x96, 0x94,
        0x94, 0xDF, 0x98, 0x98, 0x98, 0x98, 0x98, 0xDF, 0x8C, 0x8E, 0x8E, 0xDF, 0x7D, 0x7C, 0x7C,
        0x7C, 0x7C, 0xDF, 0x78, 0x78, 0x78, 0x7A, 0x7A, 0xDF,
    ],
    [
        0xDF, 0xC8, 0xC8, 0xC8, 0xC8, 0xC8, 0xDF, 0xC5, 0xC5, 0xD2, 0xD2, 0xD0, 0xDF, 0xCC, 0xCC,
        0xCC, 0xDF, 0x54, 0x56, 0x56, 0x49, 0x49, 0xDF, 0x4C, 0x4C, 0x4C, 0x4C, 0x4C, 0xDF, 0x50,
        0x52, 0x52, 0x21, 0x21, 0x20, 0x20, 0x21, 0x21, 0x92, 0x92, 0xDF, 0x94, 0x94, 0x94, 0x94,
        0x94, 0xDF, 0x98, 0x99, 0x99, 0xA6, 0xA6, 0xDF, 0x8C, 0x8C, 0x8C, 0xDF, 0x88, 0x8A, 0x8A,
        0x7D, 0x7D, 0xDF, 0x78, 0x78, 0x78, 0x78, 0x78, 0xDF,
    ],
    [
        0xDF, 0xC8, 0xC8, 0xC9, 0xC9, 0xD6, 0xDF, 0xD0, 0xD0, 0xD0, 0xD0, 0xD0, 0xDF, 0xCC, 0xCC,
        0xCD, 0xDF, 0x54, 0x54, 0x54, 0x54, 0x54, 0xDF, 0x5A, 0x4D, 0x4D, 0x4C, 0x4C, 0xDF, 0x50,
        0x50, 0x50, 0x50, 0x50, 0xDF, 0x92, 0x90, 0x90, 0x90, 0x90, 0xDF, 0x94, 0x94, 0x94, 0x95,
        0x95, 0xDF, 0xA6, 0xA4, 0xA4, 0xA4, 0xA4, 0xDF, 0x8D, 0x8C, 0x8C, 0xDF, 0x88, 0x88, 0x88,
        0x88, 0x88, 0xDF, 0x86, 0x79, 0x79, 0x78, 0x78, 0xDF,
    ],
    [
        0xDF, 0xD6, 0xD6, 0xD4, 0xD4, 0xD4, 0xDF, 0xD0, 0xD0, 0xD0, 0xD0, 0xD1, 0xDF, 0xDE, 0xDE,
        0xDC, 0xDF, 0x55, 0x54, 0x54, 0x54, 0x54, 0xDF, 0x58, 0x58, 0x58, 0x5A, 0x5A, 0xDF, 0x51,
        0x50, 0x50, 0x50, 0x50, 0xDF, 0x90, 0x90, 0x90, 0x90, 0x90, 0xDF, 0x95, 0xA2, 0xA2, 0xA0,
        0xA0, 0xDF, 0xA4, 0xA4, 0xA4, 0xA4, 0xA4, 0xDF, 0xDC, 0xDE, 0xDE, 0xDF, 0x89, 0x88, 0x88,
        0x88, 0x88, 0xDF, 0x84, 0x84, 0x84, 0x86, 0x86, 0xDF,
    ],
    [
        0xDF, 0xD4, 0xD4, 0xD4, 0xD4, 0xD4, 0xDF, 0xD1, 0xD1, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDF, 0x60, 0x62, 0x62, 0x55, 0x55, 0xDF, 0x58, 0x58, 0x58, 0x58, 0x58, 0xDF, 0x5C,
        0x5E, 0x5E, 0x51, 0x51, 0xDF, 0x90, 0x91, 0x91, 0x9E, 0x9E, 0xDF, 0xA0, 0xA0, 0xA0, 0xA0,
        0xA0, 0xDF, 0xA4, 0xA5, 0xA5, 0xB2, 0xB2, 0xDF, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE,
        0x89, 0x89, 0xDF, 0x84, 0x84, 0x84, 0x84, 0x84, 0xDF,
    ],
    [
        0xDF, 0xD4, 0xD4, 0xD5, 0xD5, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDF, 0x60, 0x60, 0x60, 0x60, 0x60, 0xDF, 0x66, 0x59, 0x59, 0x58, 0x58, 0xDF, 0x5C,
        0x5C, 0x5C, 0x5C, 0x5C, 0xDF, 0x9E, 0x9C, 0x9C, 0x9C, 0x9C, 0xDF, 0xA0, 0xA0, 0xA0, 0xA1,
        0xA1, 0xDF, 0xB2, 0xB0, 0xB0, 0xB0, 0xB0, 0xDF, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDE, 0xDE, 0x85, 0x85, 0x84, 0x84, 0xDF,
    ],
    [
        0xDF, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDF, 0x61, 0x60, 0x60, 0x60, 0x60, 0xDF, 0x64, 0x64, 0x64, 0x66, 0x66, 0xDF, 0x5D,
        0x5C, 0x5C, 0x5C, 0x5C, 0xDF, 0x9C, 0x9C, 0x9C, 0x9C, 0x9C, 0xDF, 0xA1, 0xAE, 0xAE, 0xAC,
        0xAC, 0xDF, 0xB0, 0xB0, 0xB0, 0xB0, 0xB0, 0xDF, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0xDF,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0x61, 0x61, 0xDF, 0x64, 0x64, 0x64, 0x64, 0x64, 0xDF, 0x68,
        0x6A, 0x6A, 0x5D, 0x5D, 0xDF, 0x9C, 0x9D, 0x9D, 0xAA, 0xAA, 0xDF, 0xAC, 0xAC, 0xAC, 0xAC,
        0xAC, 0xDF, 0xB0, 0xB1, 0xB1, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0x65, 0x65, 0x64, 0x64, 0xDF, 0x68,
        0x68, 0x68, 0x68, 0x68, 0xDF, 0xAA, 0xA8, 0xA8, 0xA8, 0xA8, 0xDF, 0xAC, 0xAC, 0xAC, 0xAD,
        0xAD, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0xDF, 0x69,
        0x68, 0x68, 0x68, 0x68, 0xDF, 0xA8, 0xA8, 0xA8, 0xA8, 0xA8, 0xDF, 0xAD, 0xDE, 0xDE, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDE, 0xDE, 0x69, 0x69, 0xDF, 0xA8, 0xA9, 0xA9, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD,
        0x3E, 0x3E, 0x3C, 0x3C, 0x3E, 0x3E, 0x3C, 0x3C, 0x3E, 0x3E, 0xDD, 0xDD, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0x32, 0x32, 0x30, 0x30,
        0x32, 0x32, 0x3D, 0x3D, 0x3C, 0x3C, 0x3D, 0x3D, 0x42, 0x42, 0x40, 0x40, 0x42, 0x42, 0xDD,
        0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDD, 0xDD, 0x26, 0x26, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30,
        0x30, 0x30, 0x31, 0x31, 0x36, 0x36, 0x41, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41,
        0x41, 0x46, 0x46, 0xDD, 0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDD, 0xDD, 0x26, 0x26, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x26, 0x26, 0x31, 0x31,
        0x36, 0x36, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x36, 0x36, 0x41, 0x41, 0x46, 0x46, 0x44,
        0x44, 0x44, 0x44, 0x44, 0x44, 0x46, 0x46, 0xDD, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0x25, 0x25, 0x24, 0x24, 0x25, 0x25, 0x2A, 0x2A, 0x28, 0x28,
        0x2A, 0x2A, 0x35, 0x35, 0x34, 0x34, 0x35, 0x35, 0x3A, 0x3A, 0x38, 0x38, 0x3A, 0x3A, 0x45,
        0x45, 0x44, 0x44, 0x45, 0x45, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0x29, 0x29, 0x28, 0x28, 0x28, 0x28,
        0x28, 0x28, 0x29, 0x29, 0x2E, 0x2E, 0x39, 0x39, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x39,
        0x39, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0x29, 0x29,
        0x2E, 0x2E, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2C, 0x2E, 0x2E, 0x39, 0x39, 0xDE, 0xDE, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDE, 0xDE, 0x2D, 0x2D, 0x2C, 0x2C, 0x2D, 0x2D, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
    [
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDE, 0xDE, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
        0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC, 0xDC,
    ],
];
