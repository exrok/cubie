use crate::Face;
use crate::EdgeMap;
use crate::CornerMap;
use crate::Cube;
use crate::FixedCentersCube;
use crate::cube::corner::Corner;
use crate::cube::center::CenterMap;

#[derive(Default,Clone,PartialEq,Eq,Debug)]
pub struct TileMap {
    pub map: [[ Option<Face>;9];6]
}


impl From<Cube> for TileMap {
    fn from(cube: Cube) -> TileMap {
        let mut tilemap:TileMap = Default::default();
        tilemap.store_centers(cube.centers());
        tilemap.store_edges(cube.edges());
        tilemap.store_corners(cube.corners());
        tilemap
    }
}
impl From<FixedCentersCube> for TileMap {
    fn from(cube: FixedCentersCube) -> TileMap {
        let mut tilemap:TileMap = Default::default();
        tilemap.store_identity_centers();
        tilemap.store_edges(cube.edges);
        tilemap.store_corners(cube.corners);
        tilemap
    }
}

impl From<CenterMap> for TileMap {
    fn from(centers: CenterMap) -> TileMap {
        let mut tilemap:TileMap = Default::default();
        tilemap.store_centers(centers);
        tilemap
    }
}
impl From<CornerMap> for TileMap {
    fn from(corners: CornerMap) -> TileMap {
        let mut tilemap:TileMap = Default::default();
        tilemap.store_identity_centers();
        tilemap.store_corners(corners);
        tilemap
    }
}

impl From<EdgeMap> for TileMap {
    fn from(edges: EdgeMap) -> TileMap {
        let mut tilemap:TileMap = Default::default();
        tilemap.store_identity_centers();
        tilemap.store_edges(edges);
        tilemap
    }
}
const FACEMAP: [Face;6] = [
    Face::Up,
    Face::Down,
    Face::Front,
    Face::Back,
    Face::Right,
    Face::Left,
]; 
impl TileMap {
/// Render a 3d picture of the cube using VT escape codes on a compatible 256-color terminal.
///
/// By default, `Front` is <span style="border-bottom:2px solid  #ff0000;">red</span> ,
/// `Back` is <span style="border-bottom:2px solid  #ffaf00;">orange</span>,
/// `Up` is <span style="border-bottom:2px solid  #ffff00;">yellow</span>,
/// `Down` is <span style="border-bottom:2px solid  #e4e4e4;">white</span>,
/// `Right` is <span style="border-bottom:2px solid  #5fd700;">green</span> and
/// `Left` is <span style="border-bottom:2px solid  #0087ff;">blue</span>.
///
/// # Example
/// 
/// ```
/// println!("{}", speedcube::Move::Rcw.cube().tilemap().terminal_display());
/// println!("{}", speedcube::Move::Ucw.corners().tilemap().terminal_display());
/// ```
///
/// Will output:    
/// <div>
/// <img  style="width:100%; max-width:207px;image-rendering: pixelated;
///    image-rendering: -moz-crisp-edges;image-rendering: crisp-edges;"
///   src="data:image/png;base64,
/// iVBORw0KGgoAAAANSUhEUgAAAEUAAABrBAMAAADTBVJcAAAAG1BMVEVBAAAICAgAh////wD/rwD/
/// AABf1wDk5OR2dnabo1jqAAAAAXRSTlMAQObYZgAAAtVJREFUeAHN1bGR2zAQhWG6AzyalJGeWrgW
/// 0MAFaIEtKL4MZXv/WQyFwRHCWJE3gGzpGzw+XrALw/wKi4+az2YgazX6rD9u+kHuGMgnCJPUEwyE
/// kRtQQ9wQBAFhNrW3uAFU5ibpScx8hBrECRImqRLMxxrOIM6sTZjfOoO03htgJGclYYj1IEgTlJkt
/// CfMZFg9a73sbBNKWNp1GxO25DTJ2mElyQxAm5ybICCYlYQgizszeBN2Oo/Yyo9oLk59BZrbaKzx7
/// YfIZhLnohfnjQZjrXpgHQZhRL8zDg8a9MB501St4r2rEVaHrZdZ7YQjCLG0vI0vtJTO1l32p0/C/
/// 5ezlQXbyrdwQhOl7YQxhCGL6XhiGXgQxXa/TAOq/ul6NOQWo77VcTNdruZy21zUBYcZBFVUzJiAM
/// t7xGBE1Gtzl56DGNYjS5BfIKASqbBPk5CeJMmgQZSUmToMSEl/ck0CCsCYJcTRs0LD8J8pkE+UyC
/// KpoSEGQ2kHfmH/by3u/lVT9I7vfyeldPMBBGbkBPEqtRAdnpJqohBQMphjjlpuhJzHwFIwwnSBgQ
/// ZMd8xeA3nGcUhnY8LjzWJ2lPYXjwPZv5hjDtGYsw94CJ32sstx/3xLLpNFrvZo7ueZKZpGq+7BNz
/// tL2UEiYJY40w32Zicw8/Y6LMKJKpFVPO5+HnTZiisNCPdSlMgYAKJglT3HxYXBTG20WMNgs6jYiL
/// fHi7hCGO7zC8QOKwmMMDiPNPDC+QuFJ2YTaM+NnvMyO/ImCyqtFBhjDJ97LFmcVkYRIdyfB+bows
/// uzBRZnTDsCCF6fdyLNpUMHUvY7q97E3avYxp9nIUJmKavZzavUxQNSqjvexBfo72sr9Gv220lzFZ
/// /gKHe7m+RgzkGmFuGMgIVQMZI8x0L+f/ai8XkJ2vSDHEqTFhOIfIbzjP4YIrzTlq1J7hjXsmzzPp
/// NX0/8/f8/t8LNCWgt/byX1Vp2biqclFaAAAAAElFTkSuQmCC">
/// </div>
    pub fn terminal_display(&self) -> impl fmt::Display + '_ {
        return TileMap3dFmt{fm: &self};
    }
    pub fn store_identity_centers(&mut self) {
        for face in Face::faces() {
            self.map[face as usize][4] = Some(face);
        }
    }
    pub fn store_centers(&mut self, centers: CenterMap) {
        for face in Face::faces() {
            self.map[centers.get(face) as usize][4] = Some(face);
        }
    }
    pub fn store_edges(&mut self, edges: EdgeMap) {
        let fm: &mut [Option<Face>;54] = unsafe {std::mem::transmute(&mut self.map)};
        const EFACE_INDEX: &[(u8,u8)] = &[
            (46,3), 
            (52,12), 
            (37,5), 
            (43,14), 
            (32,48), 
            (21,50), 
            (23,39), 
            (30,41), 
            (28,1), 
            (25,10), 
            (19,7), 
            (34,16), 
        ];
        for (edge, (pos, flipped)) in edges.iter() {
            let (mut a, mut b) = edge.faces(); 
            let position_parity = ((edge as u8 ^ pos as u8) >> 2) & 1;
            if position_parity != (flipped as u8) {
                std::mem::swap(&mut a, &mut b);
            }
            let (a_index, b_index) = EFACE_INDEX[pos as usize];
            fm[a_index as usize] = Some(a);
            fm[b_index as usize] = Some(b);
        }
    }

    pub fn store_corners(&mut self, cm: CornerMap) {
        let mut xm = 0x5050505_04040404;
        let mut zm = 0x3030202_03030202;
        let ym = 0x01000100_01000100;
        let pm = 0x08000008_00080800;
        const MASK:u64 = 0x08080808_08080808;

        let pfilter = |x| (MASK - x) | x;

        let parity = (!((cm.set << 3)^(cm.set << 2)^(cm.set << 1))) & MASK;

        let b_flip =(!pfilter((parity ^ pm) >> 3)) & (xm ^ zm); // adjust side facelet  
        xm ^= b_flip; 
        zm ^= b_flip; 

        let mnx = (cm.set | (cm.set >> 1)) & parity;
        let cm = cm.set ^ mnx ^ (mnx<<1);

        let cw =  pfilter((cm & MASK) >> 3);
        let ccw = pfilter(((cm>>1) & MASK)  >> 3);
        let nil = !(cw | ccw);

        let xmj = nil&xm | ccw&zm | cw&ym; // apply orientation 
        let ymj = nil&ym | ccw&xm | cw&zm;
        let zmj = nil&zm | ccw&ym | cw&xm;
        let fm: &mut [Option<Face>;54] = unsafe {std::mem::transmute(&mut self.map)};

        for _i in 0..8 {
            let i = _i*8;
            use Corner::*;
            let (xp, yp, zp) = match Corner::from((cm>>i) as u8) {
                ULF => (47, 6,18), DLF => (53, 9,24), ULB => (45, 0,29), URF => (36, 8,20),
                URB => (38, 2,27), DLB => (51,15,35), DRF => (42,11,26), DRB => (44,17,33),
            };
            fm[xp] = Some(unsafe {std::mem::transmute((xmj >> i) as u8)});
            fm[yp] = Some(unsafe {std::mem::transmute((ymj >> i) as u8)});
            fm[zp] = Some(unsafe {std::mem::transmute((zmj >> i) as u8)});
        }
    }
}


struct TileMap3dFmt<'a>{
    fm: &'a TileMap
}
use std::fmt;
impl fmt::Display for TileMap3dFmt<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let fm: &[Option<Face>;54] = unsafe {std::mem::transmute(&self.fm.map)};

        let color_code = |a:&Option<Face>| match a {
            Some(Face::Up) => 226, // yellow
            Some(Face::Down) => 254, // white
            Some(Face::Front) => 196, // red
            Some(Face::Back) => 214, // orange
            Some(Face::Right) => 76, // greeen
            Some(Face::Left) => 33, // blue
            None => 243, // dark grey 
        };
        let mut prev_style = 0;
        for line in CLI_CUBE_IMAGE {
            f.write_str("\x1b[38;5;232m")?;
            for block in line.iter() {
                let chr = [" ","▄", "▀","█"][(block&0b11) as usize];
                let face_index = (block >> 2) as usize;
                let style = fm.get(face_index).map(color_code).unwrap_or(0);
                if prev_style != style {
                    if style == 0 {
                        f.write_str("\x1b[49m")?;
                    }  else {
                        write!(f, "\x1b[48;5;{}m", style)?;
                    }
                }
                prev_style = style;
                f.write_str(chr)?;
            }
            f.write_str("\x1b[0m\n")?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn tile_rotations_conversions() {
        let mut map_table: [TileMap; 24] = Default::default();
        let mut i = 0;
        fn assert_equal_filled_tiles(a:&TileMap, b:&TileMap, skip_centers:bool) {
            for (face_a,face_b) in a.map.iter().zip(b.map.iter()) {
                for (index,x) in face_a.iter().zip(face_b.iter()).enumerate() {
                    if (index == 4 && skip_centers) { continue; } // skip centers
                    if let (Some(face_a),Some(face_b)) = x {
                        assert_eq!(face_a,face_b);
                    }
                }
            }

        }
        for (rotation_cube, entry) in crate::moves::ROTATION_TABLE.iter().zip(map_table.iter_mut()) {
            *entry = rotation_cube.tilemap();
            assert_equal_filled_tiles(entry, &rotation_cube.corners().into(),true);
            assert_equal_filled_tiles(entry, &rotation_cube.centers().into(),false);
            assert_equal_filled_tiles(entry, &rotation_cube.edges().into(),true);

            //rotations cubes should be all solved and specify every piece
            for face in entry.map.iter() {
                let center_tile = face[0].unwrap();
                for tile in face.iter() {
                    assert_eq!(tile.unwrap(), center_tile);
                }
            }
        }
        //All rotations cubes are distinct, the tile maps should be as well
        for x in 0..24usize {
            for y in (x+1)..24 {
                assert_ne!(&map_table[x], &map_table[y]);
            }
        }
    }
}

pub const CLI_CUBE_IMAGE: &[[u8;69]] = &[
   [0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0xB6,0xDF,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0x02,0x02,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDF,0x76,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0xB6,0xB6,0xB4,0xB4,0xB4,0xDF,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDF,0x74,0x74,0x74,0x76,0x76,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0xBA,0xBA,0xB8,0xDF,0xB4,0xB4,0xB4,0xB4,0xB4,0xDF,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDD,0xDD,0x0E,0x0E,0x0C,0x0C,0x0E,0x0E,0x01,0x01,0x00,0x00,0x01,0x01,0x06,0x06,0x04,0x04,0x06,0x06,0xDD,0xDD,
0xDC,0xDC,0xDC,0xDC,0xDF,0x74,0x74,0x74,0x74,0x74,0xDF,0x70,0x72,0x72,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDD,0xDD,0xBE,0xDF,0xB8,0xB8,0xB8,0xB8,0xB8,0xDF,0xB4,0xB4,0xB5,0xB5,0xC2,0xDF,0xDC,0xDD,0xDD,0x1A,
0x1A,0x0D,0x0D,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0D,0x0D,0x12,0x12,0x05,0x05,0x04,0x04,0x04,0x04,0x04,0x04,0x05,0x05,
0x0A,0x0A,0xDD,0xDD,0xDF,0x82,0x75,0x75,0x74,0x74,0xDF,0x70,0x70,0x70,0x70,0x70,0xDF,0x6E,0xDD,0xDD,0xDC,0xDC,0xDC,],
[0xDD,0xBE,0xBE,0xBC,0xBC,0xBC,0xDF,0xB8,0xB8,0xB8,0xB8,0xB9,0xDF,0xC2,0xC2,0xC0,0xC1,0xC1,0x1A,0x1A,0x18,0x18,0x18,
0x18,0x18,0x18,0x1A,0x1A,0x0D,0x0D,0x12,0x12,0x10,0x10,0x10,0x10,0x10,0x10,0x12,0x12,0x05,0x05,0x0A,0x0A,0x08,0x08,
0x08,0x08,0x08,0x08,0x0A,0x0A,0x81,0x80,0x82,0x82,0xDF,0x71,0x70,0x70,0x70,0x70,0xDF,0x6C,0x6C,0x6C,0x6E,0x6E,0xDD,],
[0xDF,0xBC,0xBC,0xBC,0xBC,0xBC,0xDF,0xB9,0xB9,0xC6,0xC6,0xC4,0xDF,0xC0,0xC0,0xC0,0xDF,0x48,0x4A,0x4A,0x19,0x19,0x18,
0x18,0x19,0x19,0x1E,0x1E,0x1C,0x1C,0x1E,0x1E,0x11,0x11,0x10,0x10,0x11,0x11,0x16,0x16,0x14,0x14,0x16,0x16,0x09,0x09,
0x08,0x08,0x09,0x09,0x9A,0x9A,0xDF,0x80,0x80,0x80,0xDF,0x7C,0x7E,0x7E,0x71,0x71,0xDF,0x6C,0x6C,0x6C,0x6C,0x6C,0xDF,],
[0xDF,0xBC,0xBC,0xBD,0xBD,0xCA,0xDF,0xC4,0xC4,0xC4,0xC4,0xC4,0xDF,0xC0,0xC0,0xC1,0xDF,0x48,0x48,0x48,0x48,0x48,0xDF,
0x4E,0x1D,0x1D,0x1C,0x1C,0x1C,0x1C,0x1C,0x1C,0x1D,0x1D,0x22,0x22,0x15,0x15,0x14,0x14,0x14,0x14,0x14,0x14,0x15,0x15,
0xDF,0x9A,0x98,0x98,0x98,0x98,0xDF,0x81,0x80,0x80,0xDF,0x7C,0x7C,0x7C,0x7C,0x7C,0xDF,0x7A,0x6D,0x6D,0x6C,0x6C,0xDF,],
[0xDF,0xCA,0xCA,0xC8,0xC8,0xC8,0xDF,0xC4,0xC4,0xC4,0xC4,0xC5,0xDF,0xCE,0xCE,0xCC,0xDF,0x49,0x48,0x48,0x48,0x48,0xDF,
0x4C,0x4C,0x4C,0x4E,0x4E,0x1D,0x1D,0x22,0x22,0x20,0x20,0x20,0x20,0x20,0x20,0x22,0x22,0x15,0x15,0x96,0x96,0x94,0x94,
0xDF,0x98,0x98,0x98,0x98,0x98,0xDF,0x8C,0x8E,0x8E,0xDF,0x7D,0x7C,0x7C,0x7C,0x7C,0xDF,0x78,0x78,0x78,0x7A,0x7A,0xDF,],
[0xDF,0xC8,0xC8,0xC8,0xC8,0xC8,0xDF,0xC5,0xC5,0xD2,0xD2,0xD0,0xDF,0xCC,0xCC,0xCC,0xDF,0x54,0x56,0x56,0x49,0x49,0xDF,
0x4C,0x4C,0x4C,0x4C,0x4C,0xDF,0x50,0x52,0x52,0x21,0x21,0x20,0x20,0x21,0x21,0x92,0x92,0xDF,0x94,0x94,0x94,0x94,0x94,
0xDF,0x98,0x99,0x99,0xA6,0xA6,0xDF,0x8C,0x8C,0x8C,0xDF,0x88,0x8A,0x8A,0x7D,0x7D,0xDF,0x78,0x78,0x78,0x78,0x78,0xDF,],
[0xDF,0xC8,0xC8,0xC9,0xC9,0xD6,0xDF,0xD0,0xD0,0xD0,0xD0,0xD0,0xDF,0xCC,0xCC,0xCD,0xDF,0x54,0x54,0x54,0x54,0x54,0xDF,
0x5A,0x4D,0x4D,0x4C,0x4C,0xDF,0x50,0x50,0x50,0x50,0x50,0xDF,0x92,0x90,0x90,0x90,0x90,0xDF,0x94,0x94,0x94,0x95,0x95,
0xDF,0xA6,0xA4,0xA4,0xA4,0xA4,0xDF,0x8D,0x8C,0x8C,0xDF,0x88,0x88,0x88,0x88,0x88,0xDF,0x86,0x79,0x79,0x78,0x78,0xDF,],
[0xDF,0xD6,0xD6,0xD4,0xD4,0xD4,0xDF,0xD0,0xD0,0xD0,0xD0,0xD1,0xDF,0xDE,0xDE,0xDC,0xDF,0x55,0x54,0x54,0x54,0x54,0xDF,
0x58,0x58,0x58,0x5A,0x5A,0xDF,0x51,0x50,0x50,0x50,0x50,0xDF,0x90,0x90,0x90,0x90,0x90,0xDF,0x95,0xA2,0xA2,0xA0,0xA0,
0xDF,0xA4,0xA4,0xA4,0xA4,0xA4,0xDF,0xDC,0xDE,0xDE,0xDF,0x89,0x88,0x88,0x88,0x88,0xDF,0x84,0x84,0x84,0x86,0x86,0xDF,],
[0xDF,0xD4,0xD4,0xD4,0xD4,0xD4,0xDF,0xD1,0xD1,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDF,0x60,0x62,0x62,0x55,0x55,0xDF,
0x58,0x58,0x58,0x58,0x58,0xDF,0x5C,0x5E,0x5E,0x51,0x51,0xDF,0x90,0x91,0x91,0x9E,0x9E,0xDF,0xA0,0xA0,0xA0,0xA0,0xA0,
0xDF,0xA4,0xA5,0xA5,0xB2,0xB2,0xDF,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0x89,0x89,0xDF,0x84,0x84,0x84,0x84,0x84,0xDF,],
[0xDF,0xD4,0xD4,0xD5,0xD5,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDF,0x60,0x60,0x60,0x60,0x60,0xDF,
0x66,0x59,0x59,0x58,0x58,0xDF,0x5C,0x5C,0x5C,0x5C,0x5C,0xDF,0x9E,0x9C,0x9C,0x9C,0x9C,0xDF,0xA0,0xA0,0xA0,0xA1,0xA1,
0xDF,0xB2,0xB0,0xB0,0xB0,0xB0,0xDF,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0x85,0x85,0x84,0x84,0xDF,],
[0xDF,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDF,0x61,0x60,0x60,0x60,0x60,0xDF,
0x64,0x64,0x64,0x66,0x66,0xDF,0x5D,0x5C,0x5C,0x5C,0x5C,0xDF,0x9C,0x9C,0x9C,0x9C,0x9C,0xDF,0xA1,0xAE,0xAE,0xAC,0xAC,
0xDF,0xB0,0xB0,0xB0,0xB0,0xB0,0xDF,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0xDF,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0x61,0x61,0xDF,
0x64,0x64,0x64,0x64,0x64,0xDF,0x68,0x6A,0x6A,0x5D,0x5D,0xDF,0x9C,0x9D,0x9D,0xAA,0xAA,0xDF,0xAC,0xAC,0xAC,0xAC,0xAC,
0xDF,0xB0,0xB1,0xB1,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,
0xDE,0x65,0x65,0x64,0x64,0xDF,0x68,0x68,0x68,0x68,0x68,0xDF,0xAA,0xA8,0xA8,0xA8,0xA8,0xDF,0xAC,0xAC,0xAC,0xAD,0xAD,
0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDE,0xDE,0xDF,0x69,0x68,0x68,0x68,0x68,0xDF,0xA8,0xA8,0xA8,0xA8,0xA8,0xDF,0xAD,0xDE,0xDE,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0x69,0x69,0xDF,0xA8,0xA9,0xA9,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0x3E,0x3E,0x3C,0x3C,0x3E,0x3E,0x3C,0x3C,0x3E,0x3E,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDD,0xDD,0x32,0x32,0x30,0x30,0x32,0x32,0x3D,0x3D,0x3C,0x3C,0x3D,0x3D,0x42,0x42,0x40,0x40,0x42,0x42,0xDD,0xDD,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0x26,
0x26,0x31,0x31,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x31,0x36,0x36,0x41,0x41,0x40,0x40,0x40,0x40,0x40,0x40,0x41,0x41,
0x46,0x46,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0x26,0x26,0x24,0x24,0x24,
0x24,0x24,0x24,0x26,0x26,0x31,0x31,0x36,0x36,0x34,0x34,0x34,0x34,0x34,0x34,0x36,0x36,0x41,0x41,0x46,0x46,0x44,0x44,
0x44,0x44,0x44,0x44,0x46,0x46,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0x25,0x25,0x24,
0x24,0x25,0x25,0x2A,0x2A,0x28,0x28,0x2A,0x2A,0x35,0x35,0x34,0x34,0x35,0x35,0x3A,0x3A,0x38,0x38,0x3A,0x3A,0x45,0x45,
0x44,0x44,0x45,0x45,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,
0xDE,0x29,0x29,0x28,0x28,0x28,0x28,0x28,0x28,0x29,0x29,0x2E,0x2E,0x39,0x39,0x38,0x38,0x38,0x38,0x38,0x38,0x39,0x39,
0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDE,0xDE,0x29,0x29,0x2E,0x2E,0x2C,0x2C,0x2C,0x2C,0x2C,0x2C,0x2E,0x2E,0x39,0x39,0xDE,0xDE,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0x2D,0x2D,0x2C,0x2C,0x2D,0x2D,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,],
[0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDE,0xDE,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,
0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC]];
